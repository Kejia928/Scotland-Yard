# Scotland-Yard game project report

## Introduction
Scotland Yard is a kind of reasoning game, which has two different roles, that are thief (Mr.X) and detectives. Both roles have tickets to travel in the whole graph, and the travel log will record the location of Mr.X in some specific rounds and used ticket. In this game, the task for the detective is to catch Mr.X according to the travel log of Mr.X before the game over, and the task for Mr.X is to avoid the detectives tracking and not be caught until the game over. This project has two parts, one is a game model and another one is artificial intelligence (AI). The model part is implementing the full version for the Scotland Yard game without the beginning version. Additionally, the AI part is created as a simple intelligence component that makes the player automatically choose a movement to play the game.

## Summary of code
The model part should complete two class that are MyGameStateFactory and MyModelFactory. In the MyGameStateFactory class, we create an inner class that is the MyGameState that implements the GameState interface. When the game started, the eight methods from the interface should be overridden, initialised and realized basic function. Additionally, we check some prerequisites, which are mainly about setup, player and winner, before the game start. 

During the game, the player needs to have a list of available moves. Two distinct move types are Single and Double move. For the SingleMove method, we loop the adjacent nodes around the player current location and find transport between the player location and the adjacent node. If the player has required tickets and the adjacent node is not occupied by detectives, add them to the SingleMove list. In addition, we also consider the SECRET ticket that can be used as any other ticket except the DOUBLE ticket, so we make the SingleMove list to add all moves between player location and adjacent node by using SECRET ticket if the current player has it. Finally, we can get all possible SingleMove by using this method. Afterwards, the DoubleMove function can be done, which can be seen as the player moves two steps by calling the SingleMove method twice. When we first time calling SingleMove, we can get a list containing all first step moves for the player. Next, we will take the first step destination as s source and find the second step list for each first step. Then, we can get all possible combination for the first and second step and add them to the DoubleMove list. When both methods are completed, we need a function to identify the type of the player and return all available moves that player can make. 

When a player makes a move, there need to return a new GameState, which implements this in the advance function that updates location and ticket for the current moved player, remaining players and travel log. In advance function, the visitor design pattern will be mainly used. There is generic visitor method in each move type and a visitor interface in the Move interface. When we call the visit method of move with the same type of parameter and visitor object, the method for each move should be overridden and returns the object of this type. In visitor pattern, the dynamic dispatch will select which visitor method of move type should be called. Firstly, when we update the player location, we use a visitor object with integer type as a parameter to call the visit method of move and override the visitor method for both move type to return their move destination in the anonymous inner class. Secondly, to change the number of tickets of the player, we call the use method from the player. But if the player is detectives, based on the game rule, we also need to give this ticket to Mr.X. Thirdly, we update the remaining player, if the current moved player is Mr.X, we change the remaining become to all detective players. If the current moved player is detectives, we put the rest not moved detectives into remaining and when all valid detectives moved, change remaining to Mr.X. Fourthly, travel log should be held newest travel information from Mr.X because detective need use it to track Mr.X. We also use visitor in here, but the type should change to LogEntry and make it return a revel or hidden LogEntry according to the round number. Finally, we use all the newest objects to return a new GameState. 

After the player moving, we need to check the game is over or not, which should check whether there is a winner. There are two situations we need to consider. When there no round left and Mr.X is not caught, or all detectives do not have any available moves, Mr.X is the winner. Otherwise, when Mr.X is caught or Mr.X does not have any available moves, all detectives are the winner. We will check these conditions before the constructor of MyGameState and store the winner list in the attribute of MyGameState class because the game needs to run these before the next round started.

In the MyModelFactory class that is, this class use observes design pattern. Observer pattern will be used when there is a one-to-many relationship between objects, which can automatically notify an object when its dependent object is modified. In this game, when the game over, the observer will change the model and sent a game event that is GAME_OVER or MOVE_MADE. When this class finished, all part of the model is completed, and all tests should be passed.

In the second part for AI of this project, firstly, complete the calculating distance between two-point that is based on the Dijkstra algorithm. We create an empty matrix, which size is the number of nodes plus one times the number of nodes plus one, and make it holds all shortest distance between each point for the whole graph. However, the Dijkstra algorithm only applies for one-to-many points, so we do a change for Dijkstra. Firstly, we loop all the nodes in the graph and loop all the nodes again inside this loop, which means the distance between a fixed point to all other points appeared. Then, in the inner loop, we use two lists that hold points of already looped, ready looping, respectively. we loop the already node to find all adjacent nodes for each already looped node and put them into the ready node, and then loop the ready node list to get distance based on the loop times and store it into the matrix. For example, the fixed point is 1 and the ready node is 1, because this is a zeroth times loop, the distance of 1 to 1 is zero that store it in the matrix and put 1 to the already node. Afterwards, we loop the already node, the linked node around point 1 will be got and put into the ready node. Then, loop ready node and this is the first time loop, so the distance between fixed point 1 to each ready node is one and put their distance into the matrix. We will do the same procedure again and again until all node and all fixed node looped. Finally, the matrix of the whole graph will be completed and when we query the distance between two points, we only need to input the position of two points in the matrix to get the distance between two points. 

Next, there needs a scoring function to evaluate the move that makes by MrxAi. The scoring function depended on the distance between the move target location and all location of detectives. The security number is set for each move, if the move target is in the detective move range, the security number will become zero, otherwise, it is one. In addition, we add a ticket score and set it as fifty. We calculate ticket by fifty minus the number of used tickets multiply ten, which will make SingleMove score higher than DoubleMove because we want AI to firstly chooses SingleMove. Also, we add a condition about the SECRET ticket, which is if move used SECRET tickets, it will minus extra ten points. Because the SECRET ticket is valuable, and we want AI to use other tickets primarily. This function also considers the freedom for the move, which means the number of adjacent nodes of the move target location. At the end of the function, the total score can be calculated by the distance between target location and all location of detectives plus the freedom score plus the ticket score and multiplied by security number, which means the total score is the lowest score when the security number is zero.

Finally, the minimax will make the AI better. Minimax does not find the theoretical optimal solution, because the theoretical optimal solution often depends on whether the opponent is stupid, which means the detective always choose to move far away from Mr.X. Suppose that every step of the detective will lead Mr.X to the theoretically minimize valuable move, that is every step of the detective is perfect. So, the strategy for Mr.X should be to choose the maximum value move that the detective can achieve in the worst case. Overall, Mr.X is to find out the best move in the worst case. In the minimax, we also use alpha-beta pruning to make the runtime shorter. Alpha-beta pruning is used to prune the meaningless and unnecessary branches in the search tree. We set alpha as lower bound, and beta is the upper bound. In the maximizing level in the tree, if the move score is bigger than alpha, we will update alpha. In the minimizing level in the tree, if the move score is smaller than beta, we will update beta. When the alpha bigger or equal to beta, we will prune the branches.

## Reflecting on achievements
In the first part of this project, we can pass all the tests and run the game without bug, and based on the original, we use the stream function to simplify our code. In the second part for our minimax algorithm, we also try to see all the detectives as a player and combine their moves as one move in the minimized level. But we failed to do it. When we use the Cartesian product to combine all possible mobile combinations, although there is no error, it can only run when there is only one detective and sometimes can work for two detectives. We try to fix this bug, but it is not successful. So now we use the method is that we will recurrence every detective as a player and add the condition that only after all the detectives recurse, then they can return to the maximum level. Compare these two methods, we think these two methods just have slight difference, but maybe all the detectives as a player are better than recurrence every detective. For the depth of the tree, the depth of recurrence of every detective as a player is deeper than all the detectives as a player. For example, we do one round for the minimax tree and set the number of detectives as five, the depth of recurrence of every detective is six, but the depth of all the detectives as a player is only one. However, for the horizontal level for each depth, the combination of the moves will longer than all available moves of detectives. For example, we have 5 detectives and each detective have 2 available moves. For the recurrence of every detective, the maximum length of the horizontal level is 8. But, for the combination of moves, the length of the horizontal level is 32. Therefore, we think all the detectives as a player maybe is better, because his depth is shallower. In future improvement, we will try to fix the bug about the Cartesian product. In addition, we also need to improve our scoring function. For example, we can design an equation to consider all the effect for the score of moves, such as ticket, directions, direction and distance. Finally, we also try to give an AI to detectives. The basic idea for this AI is to make a detective based on Mr.X travel log and to find out Mr.X possible move range, make detectives move close to the range. The ideal is successful, but the scoring for detective moves still need to improve. We think we can also consider the direction for the detective move, which means all possible moving points around the Mr.X were surrounded by detective, because the number of detectives may be more than the number of Mr.X. 

